.TH "pgmspace.h" 3 "13 Feb 2016" "Version 1.8.0svn" "avr-libc" \" -*- nroff -*-
.ad l
.nh
.SH NAME
pgmspace.h \- 
.SH SYNOPSIS
.br
.PP
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fB__need_size_t\fP"
.br
.ti -1c
.RI "#define \fB__ATTR_PROGMEM__\fP   __attribute__((__progmem__))"
.br
.ti -1c
.RI "#define \fB__ATTR_PURE__\fP   __attribute__((__pure__))"
.br
.ti -1c
.RI "#define \fBPROGMEM\fP   __ATTR_PROGMEM__"
.br
.ti -1c
.RI "#define \fBPGM_P\fP   const char *"
.br
.ti -1c
.RI "#define \fBPGM_VOID_P\fP   const void *"
.br
.ti -1c
.RI "#define \fBPSTR\fP(s)   ((const PROGMEM char *)(s))"
.br
.ti -1c
.RI "#define \fB__LPM_classic__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__LPM_tiny__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__LPM_enhanced__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__LPM_word_classic__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__LPM_word_tiny__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__LPM_word_enhanced__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__LPM_dword_classic__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__LPM_dword_tiny__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__LPM_dword_enhanced__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__LPM_float_classic__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__LPM_float_tiny__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__LPM_float_enhanced__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__LPM\fP(addr)   __LPM_classic__(addr)"
.br
.ti -1c
.RI "#define \fB__LPM_word\fP(addr)   __LPM_word_classic__(addr)"
.br
.ti -1c
.RI "#define \fB__LPM_dword\fP(addr)   __LPM_dword_classic__(addr)"
.br
.ti -1c
.RI "#define \fB__LPM_float\fP(addr)   __LPM_float_classic__(addr)"
.br
.ti -1c
.RI "#define \fBpgm_read_byte_near\fP(address_short)   __LPM((\fBuint16_t\fP)(address_short))"
.br
.ti -1c
.RI "#define \fBpgm_read_word_near\fP(address_short)   __LPM_word((\fBuint16_t\fP)(address_short))"
.br
.ti -1c
.RI "#define \fBpgm_read_dword_near\fP(address_short)   __LPM_dword((\fBuint16_t\fP)(address_short))"
.br
.ti -1c
.RI "#define \fBpgm_read_float_near\fP(address_short)   __LPM_float((\fBuint16_t\fP)(address_short))"
.br
.ti -1c
.RI "#define \fBpgm_read_ptr_near\fP(address_short)   (void*)__LPM_word((\fBuint16_t\fP)(address_short))"
.br
.ti -1c
.RI "#define \fB__ELPM_classic__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__ELPM_enhanced__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__ELPM_xmega__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__ELPM_word_classic__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__ELPM_word_enhanced__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__ELPM_word_xmega__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__ELPM_dword_classic__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__ELPM_dword_enhanced__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__ELPM_dword_xmega__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__ELPM_float_classic__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__ELPM_float_enhanced__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__ELPM_float_xmega__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__ELPM\fP(addr)   __ELPM_classic__(addr)"
.br
.ti -1c
.RI "#define \fB__ELPM_word\fP(addr)   __ELPM_word_classic__(addr)"
.br
.ti -1c
.RI "#define \fB__ELPM_dword\fP(addr)   __ELPM_dword_classic__(addr)"
.br
.ti -1c
.RI "#define \fB__ELPM_float\fP(addr)   __ELPM_float_classic__(addr)"
.br
.ti -1c
.RI "#define \fBpgm_read_byte_far\fP(address_long)   __ELPM((\fBuint32_t\fP)(address_long))"
.br
.ti -1c
.RI "#define \fBpgm_read_word_far\fP(address_long)   __ELPM_word((\fBuint32_t\fP)(address_long))"
.br
.ti -1c
.RI "#define \fBpgm_read_dword_far\fP(address_long)   __ELPM_dword((\fBuint32_t\fP)(address_long))"
.br
.ti -1c
.RI "#define \fBpgm_read_float_far\fP(address_long)   __ELPM_float((\fBuint32_t\fP)(address_long))"
.br
.ti -1c
.RI "#define \fBpgm_read_ptr_far\fP(address_long)   (void*)__ELPM_word((\fBuint32_t\fP)(address_long))"
.br
.ti -1c
.RI "#define \fBpgm_read_byte\fP(address_short)   pgm_read_byte_near(address_short)"
.br
.ti -1c
.RI "#define \fBpgm_read_word\fP(address_short)   pgm_read_word_near(address_short)"
.br
.ti -1c
.RI "#define \fBpgm_read_dword\fP(address_short)   pgm_read_dword_near(address_short)"
.br
.ti -1c
.RI "#define \fBpgm_read_float\fP(address_short)   pgm_read_float_near(address_short)"
.br
.ti -1c
.RI "#define \fBpgm_read_ptr\fP(address_short)   pgm_read_ptr_near(address_short)"
.br
.ti -1c
.RI "#define \fBpgm_get_far_address\fP(var)"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef void PROGMEM \fBprog_void\fP"
.br
.ti -1c
.RI "typedef char PROGMEM \fBprog_char\fP"
.br
.ti -1c
.RI "typedef unsigned char PROGMEM \fBprog_uchar\fP"
.br
.ti -1c
.RI "typedef \fBint8_t\fP PROGMEM \fBprog_int8_t\fP"
.br
.ti -1c
.RI "typedef \fBuint8_t\fP PROGMEM \fBprog_uint8_t\fP"
.br
.ti -1c
.RI "typedef \fBint16_t\fP PROGMEM \fBprog_int16_t\fP"
.br
.ti -1c
.RI "typedef \fBuint16_t\fP PROGMEM \fBprog_uint16_t\fP"
.br
.ti -1c
.RI "typedef \fBint32_t\fP PROGMEM \fBprog_int32_t\fP"
.br
.ti -1c
.RI "typedef \fBuint32_t\fP PROGMEM \fBprog_uint32_t\fP"
.br
.ti -1c
.RI "typedef \fBint64_t\fP PROGMEM \fBprog_int64_t\fP"
.br
.ti -1c
.RI "typedef \fBuint64_t\fP PROGMEM \fBprog_uint64_t\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "const void * \fBmemchr_P\fP (const void *, int __val, size_t __len)"
.br
.ti -1c
.RI "int \fBmemcmp_P\fP (const void *, const void *, size_t) __ATTR_PURE__"
.br
.ti -1c
.RI "void * \fBmemccpy_P\fP (void *, const void *, int __val, size_t)"
.br
.ti -1c
.RI "void * \fBmemcpy_P\fP (void *, const void *, size_t)"
.br
.ti -1c
.RI "void * \fBmemmem_P\fP (const void *, size_t, const void *, size_t) __ATTR_PURE__"
.br
.ti -1c
.RI "const void * \fBmemrchr_P\fP (const void *, int __val, size_t __len)"
.br
.ti -1c
.RI "char * \fBstrcat_P\fP (char *, const char *)"
.br
.ti -1c
.RI "const char * \fBstrchr_P\fP (const char *, int __val)"
.br
.ti -1c
.RI "const char * \fBstrchrnul_P\fP (const char *, int __val)"
.br
.ti -1c
.RI "int \fBstrcmp_P\fP (const char *, const char *) __ATTR_PURE__"
.br
.ti -1c
.RI "char * \fBstrcpy_P\fP (char *, const char *)"
.br
.ti -1c
.RI "int \fBstrcasecmp_P\fP (const char *, const char *) __ATTR_PURE__"
.br
.ti -1c
.RI "char * \fBstrcasestr_P\fP (const char *, const char *) __ATTR_PURE__"
.br
.ti -1c
.RI "size_t \fBstrcspn_P\fP (const char *__s, const char *__reject) __ATTR_PURE__"
.br
.ti -1c
.RI "size_t \fBstrlcat_P\fP (char *, const char *, size_t)"
.br
.ti -1c
.RI "size_t \fBstrlcpy_P\fP (char *, const char *, size_t)"
.br
.ti -1c
.RI "size_t \fB__strlen_P\fP (const char *)"
.br
.ti -1c
.RI "size_t \fBstrnlen_P\fP (const char *, size_t)"
.br
.ti -1c
.RI "int \fBstrncmp_P\fP (const char *, const char *, size_t) __ATTR_PURE__"
.br
.ti -1c
.RI "int \fBstrncasecmp_P\fP (const char *, const char *, size_t) __ATTR_PURE__"
.br
.ti -1c
.RI "char * \fBstrncat_P\fP (char *, const char *, size_t)"
.br
.ti -1c
.RI "char * \fBstrncpy_P\fP (char *, const char *, size_t)"
.br
.ti -1c
.RI "char * \fBstrpbrk_P\fP (const char *__s, const char *__accept) __ATTR_PURE__"
.br
.ti -1c
.RI "const char * \fBstrrchr_P\fP (const char *, int __val)"
.br
.ti -1c
.RI "char * \fBstrsep_P\fP (char **__sp, const char *__delim)"
.br
.ti -1c
.RI "size_t \fBstrspn_P\fP (const char *__s, const char *__accept) __ATTR_PURE__"
.br
.ti -1c
.RI "char * \fBstrstr_P\fP (const char *, const char *) __ATTR_PURE__"
.br
.ti -1c
.RI "char * \fBstrtok_P\fP (char *__s, const char *__delim)"
.br
.ti -1c
.RI "char * \fBstrtok_rP\fP (char *__s, const char *__delim, char **__last)"
.br
.ti -1c
.RI "size_t \fBstrlen_PF\fP (\fBuint_farptr_t\fP src)"
.br
.ti -1c
.RI "size_t \fBstrnlen_PF\fP (\fBuint_farptr_t\fP src, size_t len)"
.br
.ti -1c
.RI "void * \fBmemcpy_PF\fP (void *dest, \fBuint_farptr_t\fP src, size_t len)"
.br
.ti -1c
.RI "char * \fBstrcpy_PF\fP (char *dest, \fBuint_farptr_t\fP src)"
.br
.ti -1c
.RI "char * \fBstrncpy_PF\fP (char *dest, \fBuint_farptr_t\fP src, size_t len)"
.br
.ti -1c
.RI "char * \fBstrcat_PF\fP (char *dest, \fBuint_farptr_t\fP src)"
.br
.ti -1c
.RI "size_t \fBstrlcat_PF\fP (char *dst, \fBuint_farptr_t\fP src, size_t siz)"
.br
.ti -1c
.RI "char * \fBstrncat_PF\fP (char *dest, \fBuint_farptr_t\fP src, size_t len)"
.br
.ti -1c
.RI "int \fBstrcmp_PF\fP (const char *s1, \fBuint_farptr_t\fP s2) __ATTR_PURE__"
.br
.ti -1c
.RI "int \fBstrncmp_PF\fP (const char *s1, \fBuint_farptr_t\fP s2, size_t n) __ATTR_PURE__"
.br
.ti -1c
.RI "int \fBstrcasecmp_PF\fP (const char *s1, \fBuint_farptr_t\fP s2) __ATTR_PURE__"
.br
.ti -1c
.RI "int \fBstrncasecmp_PF\fP (const char *s1, \fBuint_farptr_t\fP s2, size_t n) __ATTR_PURE__"
.br
.ti -1c
.RI "char * \fBstrstr_PF\fP (const char *s1, \fBuint_farptr_t\fP s2)"
.br
.ti -1c
.RI "size_t \fBstrlcpy_PF\fP (char *dst, \fBuint_farptr_t\fP src, size_t siz)"
.br
.ti -1c
.RI "int \fBmemcmp_PF\fP (const void *, \fBuint_farptr_t\fP, size_t) __ATTR_PURE__"
.br
.ti -1c
.RI "\fB__attribute__\fP ((__always_inline__)) static inline size_t strlen_P(const char *s)"
.br
.ti -1c
.RI "static size_t \fBstrlen_P\fP (const char *s)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SH "Define Documentation"
.PP 
.SS "#define __ELPM_classic__(addr)"\fBValue:\fP
.PP
.nf
(__extension__({                    \
    uint32_t __addr32 = (uint32_t)(addr); \
    uint8_t __result;               \
    __asm__ __volatile__            \
    (                               \
        'out %2, %C1' '\n\t'        \
        'mov r31, %B1' '\n\t'       \
        'mov r30, %A1' '\n\t'       \
        'elpm' '\n\t'               \
        'mov %0, r0' '\n\t'         \
        : '=r' (__result)           \
        : 'r' (__addr32),           \
          'I' (_SFR_IO_ADDR(RAMPZ)) \
        : 'r0', 'r30', 'r31'        \
    );                              \
    __result;                       \
}))
.fi
.SS "#define __ELPM_dword_enhanced__(addr)"\fBValue:\fP
.PP
.nf
(__extension__({                          \
    uint32_t __addr32 = (uint32_t)(addr); \
    uint32_t __result;                    \
    __asm__ __volatile__                  \
    (                                     \
        'out %2, %C1'   '\n\t'            \
        'movw r30, %1'  '\n\t'            \
        'elpm %A0, Z+'  '\n\t'            \
        'elpm %B0, Z+'  '\n\t'            \
        'elpm %C0, Z+'  '\n\t'            \
        'elpm %D0, Z'   '\n\t'            \
        : '=r' (__result)                 \
        : 'r' (__addr32),                 \
          'I' (_SFR_IO_ADDR(RAMPZ))       \
        : 'r30', 'r31'                    \
    );                                    \
    __result;                             \
}))
.fi
.SS "#define __ELPM_dword_xmega__(addr)"\fBValue:\fP
.PP
.nf
(__extension__({                          \
    uint32_t __addr32 = (uint32_t)(addr); \
    uint32_t __result;                    \
    __asm__ __volatile__                  \
    (                                     \
        'in __tmp_reg__, %2' '\n\t'       \
        'out %2, %C1'   '\n\t'            \
        'movw r30, %1'  '\n\t'            \
        'elpm %A0, Z+'  '\n\t'            \
        'elpm %B0, Z+'  '\n\t'            \
        'elpm %C0, Z+'  '\n\t'            \
        'elpm %D0, Z'   '\n\t'            \
        'out %2, __tmp_reg__'             \
        : '=r' (__result)                 \
        : 'r' (__addr32),                 \
          'I' (_SFR_IO_ADDR(RAMPZ))       \
        : 'r30', 'r31'                    \
    );                                    \
    __result;                             \
}))
.fi
.SS "#define __ELPM_enhanced__(addr)"\fBValue:\fP
.PP
.nf
(__extension__({                    \
    uint32_t __addr32 = (uint32_t)(addr); \
    uint8_t __result;               \
    __asm__ __volatile__            \
    (                               \
        'out %2, %C1' '\n\t'        \
        'movw r30, %1' '\n\t'       \
        'elpm %0, Z+' '\n\t'        \
        : '=r' (__result)           \
        : 'r' (__addr32),           \
          'I' (_SFR_IO_ADDR(RAMPZ)) \
        : 'r30', 'r31'              \
    );                              \
    __result;                       \
}))
.fi
.SS "#define __ELPM_float_enhanced__(addr)"\fBValue:\fP
.PP
.nf
(__extension__({                          \
    uint32_t __addr32 = (uint32_t)(addr); \
    float __result;                       \
    __asm__ __volatile__                  \
    (                                     \
        'out %2, %C1'   '\n\t'            \
        'movw r30, %1'  '\n\t'            \
        'elpm %A0, Z+'  '\n\t'            \
        'elpm %B0, Z+'  '\n\t'            \
        'elpm %C0, Z+'  '\n\t'            \
        'elpm %D0, Z'   '\n\t'            \
        : '=r' (__result)                 \
        : 'r' (__addr32),                 \
          'I' (_SFR_IO_ADDR(RAMPZ))       \
        : 'r30', 'r31'                    \
    );                                    \
    __result;                             \
}))
.fi
.SS "#define __ELPM_float_xmega__(addr)"\fBValue:\fP
.PP
.nf
(__extension__({                          \
    uint32_t __addr32 = (uint32_t)(addr); \
    float __result;                       \
    __asm__ __volatile__                  \
    (                                     \
        'in __tmp_reg__, %2' '\n\t'       \
        'out %2, %C1'   '\n\t'            \
        'movw r30, %1'  '\n\t'            \
        'elpm %A0, Z+'  '\n\t'            \
        'elpm %B0, Z+'  '\n\t'            \
        'elpm %C0, Z+'  '\n\t'            \
        'elpm %D0, Z'   '\n\t'            \
        'out %2, __tmp_reg__'             \
        : '=r' (__result)                 \
        : 'r' (__addr32),                 \
          'I' (_SFR_IO_ADDR(RAMPZ))       \
        : 'r30', 'r31'                    \
    );                                    \
    __result;                             \
}))
.fi
.SS "#define __ELPM_word_classic__(addr)"\fBValue:\fP
.PP
.nf
(__extension__({                        \
    uint32_t __addr32 = (uint32_t)(addr); \
    uint16_t __result;                  \
    __asm__ __volatile__                \
    (                                   \
        'out %2, %C1'   '\n\t'          \
        'mov r31, %B1'  '\n\t'          \
        'mov r30, %A1'  '\n\t'          \
        'elpm'          '\n\t'          \
        'mov %A0, r0'   '\n\t'          \
        'in r0, %2'     '\n\t'          \
        'adiw r30, 1'   '\n\t'          \
        'adc r0, __zero_reg__' '\n\t'   \
        'out %2, r0'    '\n\t'          \
        'elpm'          '\n\t'          \
        'mov %B0, r0'   '\n\t'          \
        : '=r' (__result)               \
        : 'r' (__addr32),               \
          'I' (_SFR_IO_ADDR(RAMPZ))     \
        : 'r0', 'r30', 'r31'            \
    );                                  \
    __result;                           \
}))
.fi
.SS "#define __ELPM_word_enhanced__(addr)"\fBValue:\fP
.PP
.nf
(__extension__({                        \
    uint32_t __addr32 = (uint32_t)(addr); \
    uint16_t __result;                  \
    __asm__ __volatile__                \
    (                                   \
        'out %2, %C1'   '\n\t'          \
        'movw r30, %1'  '\n\t'          \
        'elpm %A0, Z+'  '\n\t'          \
        'elpm %B0, Z'   '\n\t'          \
        : '=r' (__result)               \
        : 'r' (__addr32),               \
          'I' (_SFR_IO_ADDR(RAMPZ))     \
        : 'r30', 'r31'                  \
    );                                  \
    __result;                           \
}))
.fi
.SS "#define __ELPM_word_xmega__(addr)"\fBValue:\fP
.PP
.nf
(__extension__({                        \
    uint32_t __addr32 = (uint32_t)(addr); \
    uint16_t __result;                  \
    __asm__ __volatile__                \
    (                                   \
        'in __tmp_reg__, %2' '\n\t'     \
        'out %2, %C1'   '\n\t'          \
        'movw r30, %1'  '\n\t'          \
        'elpm %A0, Z+'  '\n\t'          \
        'elpm %B0, Z'   '\n\t'          \
        'out %2, __tmp_reg__'           \
        : '=r' (__result)               \
        : 'r' (__addr32),               \
          'I' (_SFR_IO_ADDR(RAMPZ))     \
        : 'r30', 'r31'                  \
    );                                  \
    __result;                           \
}))
.fi
.SS "#define __ELPM_xmega__(addr)"\fBValue:\fP
.PP
.nf
(__extension__({                    \
    uint32_t __addr32 = (uint32_t)(addr); \
    uint8_t __result;               \
    __asm__ __volatile__            \
    (                               \
        'in __tmp_reg__, %2' '\n\t' \
        'out %2, %C1' '\n\t'        \
        'movw r30, %1' '\n\t'       \
        'elpm %0, Z+' '\n\t'        \
        'out %2, __tmp_reg__'       \
        : '=r' (__result)           \
        : 'r' (__addr32),           \
          'I' (_SFR_IO_ADDR(RAMPZ)) \
        : 'r30', 'r31'              \
    );                              \
    __result;                       \
}))
.fi
.SS "#define __LPM_classic__(addr)"\fBValue:\fP
.PP
.nf
(__extension__({                \
    uint16_t __addr16 = (uint16_t)(addr); \
    uint8_t __result;           \
    __asm__ __volatile__        \
    (                           \
        'lpm' '\n\t'            \
        'mov %0, r0' '\n\t'     \
        : '=r' (__result)       \
        : 'z' (__addr16)        \
        : 'r0'                  \
    );                          \
    __result;                   \
}))
.fi
.SS "#define __LPM_dword_classic__(addr)"\fBValue:\fP
.PP
.nf
(__extension__({                            \
    uint16_t __addr16 = (uint16_t)(addr);   \
    uint32_t __result;                      \
    __asm__ __volatile__                    \
    (                                       \
        'lpm'           '\n\t'              \
        'mov %A0, r0'   '\n\t'              \
        'adiw r30, 1'   '\n\t'              \
        'lpm'           '\n\t'              \
        'mov %B0, r0'   '\n\t'              \
        'adiw r30, 1'   '\n\t'              \
        'lpm'           '\n\t'              \
        'mov %C0, r0'   '\n\t'              \
        'adiw r30, 1'   '\n\t'              \
        'lpm'           '\n\t'              \
        'mov %D0, r0'   '\n\t'              \
        : '=r' (__result), '=z' (__addr16)  \
        : '1' (__addr16)                    \
        : 'r0'                              \
    );                                      \
    __result;                               \
}))
.fi
.SS "#define __LPM_dword_enhanced__(addr)"\fBValue:\fP
.PP
.nf
(__extension__({                            \
    uint16_t __addr16 = (uint16_t)(addr);   \
    uint32_t __result;                      \
    __asm__ __volatile__                    \
    (                                       \
        'lpm %A0, Z+'   '\n\t'              \
        'lpm %B0, Z+'   '\n\t'              \
        'lpm %C0, Z+'   '\n\t'              \
        'lpm %D0, Z'    '\n\t'              \
        : '=r' (__result), '=z' (__addr16)  \
        : '1' (__addr16)                    \
    );                                      \
    __result;                               \
}))
.fi
.SS "#define __LPM_dword_tiny__(addr)"\fBValue:\fP
.PP
.nf
(__extension__({                            \
    uint16_t __addr16 = (uint16_t)(addr) + __AVR_TINY_PM_BASE_ADDRESS__; \
    uint32_t __result;                      \
    __asm__                                 \
    (                                       \
        'ld %A0, z+'    '\n\t'              \
        'ld %B0, z+'    '\n\t'              \
        'ld %C0, z+'    '\n\t'              \
        'ld %D0, z'     '\n\t'              \
        : '=r' (__result), '=z' (__addr16)  \
        : '1' (__addr16)                    \
    );                                      \
    __result;                               \
}))
.fi
.SS "#define __LPM_enhanced__(addr)"\fBValue:\fP
.PP
.nf
(__extension__({                \
    uint16_t __addr16 = (uint16_t)(addr); \
    uint8_t __result;           \
    __asm__ __volatile__        \
    (                           \
        'lpm %0, Z' '\n\t'      \
        : '=r' (__result)       \
        : 'z' (__addr16)        \
    );                          \
    __result;                   \
}))
.fi
.SS "#define __LPM_float_classic__(addr)"\fBValue:\fP
.PP
.nf
(__extension__({                            \
    uint16_t __addr16 = (uint16_t)(addr);   \
    float __result;                         \
    __asm__ __volatile__                    \
    (                                       \
        'lpm'           '\n\t'              \
        'mov %A0, r0'   '\n\t'              \
        'adiw r30, 1'   '\n\t'              \
        'lpm'           '\n\t'              \
        'mov %B0, r0'   '\n\t'              \
        'adiw r30, 1'   '\n\t'              \
        'lpm'           '\n\t'              \
        'mov %C0, r0'   '\n\t'              \
        'adiw r30, 1'   '\n\t'              \
        'lpm'           '\n\t'              \
        'mov %D0, r0'   '\n\t'              \
        : '=r' (__result), '=z' (__addr16)  \
        : '1' (__addr16)                    \
        : 'r0'                              \
    );                                      \
    __result;                               \
}))
.fi
.SS "#define __LPM_float_enhanced__(addr)"\fBValue:\fP
.PP
.nf
(__extension__({                            \
    uint16_t __addr16 = (uint16_t)(addr);   \
    float __result;                         \
    __asm__ __volatile__                    \
    (                                       \
        'lpm %A0, Z+'   '\n\t'              \
        'lpm %B0, Z+'   '\n\t'              \
        'lpm %C0, Z+'   '\n\t'              \
        'lpm %D0, Z'    '\n\t'              \
        : '=r' (__result), '=z' (__addr16)  \
        : '1' (__addr16)                    \
    );                                      \
    __result;                               \
}))
.fi
.SS "#define __LPM_float_tiny__(addr)"\fBValue:\fP
.PP
.nf
(__extension__({                            \
    uint16_t __addr16 = (uint16_t)(addr) + __AVR_TINY_PM_BASE_ADDRESS__; \
    float __result;                         \
    __asm__                                 \
    (                                       \
        'ld %A0, z+'   '\n\t'               \
        'ld %B0, z+'   '\n\t'               \
        'ld %C0, z+'   '\n\t'               \
        'ld %D0, z'    '\n\t'               \
        : '=r' (__result), '=z' (__addr16)  \
        : '1' (__addr16)                    \
    );                                      \
    __result;                               \
}))
.fi
.SS "#define __LPM_tiny__(addr)"\fBValue:\fP
.PP
.nf
(__extension__({                \
    uint16_t __addr16 = (uint16_t)(addr) + __AVR_TINY_PM_BASE_ADDRESS__; \
    uint8_t __result;           \
    __asm__                     \
    (                           \
        'ld %0, z' '\n\t'       \
        : '=r' (__result)       \
        : 'z' (__addr16)        \
    );                          \
    __result;                   \
}))
.fi
.SS "#define __LPM_word_classic__(addr)"\fBValue:\fP
.PP
.nf
(__extension__({                            \
    uint16_t __addr16 = (uint16_t)(addr);   \
    uint16_t __result;                      \
    __asm__ __volatile__                    \
    (                                       \
        'lpm'           '\n\t'              \
        'mov %A0, r0'   '\n\t'              \
        'adiw r30, 1'   '\n\t'              \
        'lpm'           '\n\t'              \
        'mov %B0, r0'   '\n\t'              \
        : '=r' (__result), '=z' (__addr16)  \
        : '1' (__addr16)                    \
        : 'r0'                              \
    );                                      \
    __result;                               \
}))
.fi
.SS "#define __LPM_word_enhanced__(addr)"\fBValue:\fP
.PP
.nf
(__extension__({                            \
    uint16_t __addr16 = (uint16_t)(addr);   \
    uint16_t __result;                      \
    __asm__ __volatile__                    \
    (                                       \
        'lpm %A0, Z+'   '\n\t'              \
        'lpm %B0, Z'    '\n\t'              \
        : '=r' (__result), '=z' (__addr16)  \
        : '1' (__addr16)                    \
    );                                      \
    __result;                               \
}))
.fi
.SS "#define __LPM_word_tiny__(addr)"\fBValue:\fP
.PP
.nf
(__extension__({                            \
    uint16_t __addr16 = (uint16_t)(addr) + __AVR_TINY_PM_BASE_ADDRESS__; \
    uint16_t __result;                      \
    __asm__                                 \
    (                                       \
        'ld %A0, z+'     '\n\t'             \
        'ld %B0, z'      '\n\t'             \
        : '=r' (__result), '=z' (__addr16)  \
        : '1' (__addr16)                    \
    );                                      \
    __result;                               \
}))
.fi
.SS "#define pgm_get_far_address(var)"\fBValue:\fP
.PP
.nf
({                                                    \
        uint_farptr_t tmp;                                \
                                                      \
        __asm__ __volatile__(                             \
                                                      \
                        'ldi    %A0, lo8(%1)'           '\n\t'    \
                        'ldi    %B0, hi8(%1)'           '\n\t'    \
                        'ldi    %C0, hh8(%1)'           '\n\t'    \
                        'clr    %D0'                    '\n\t'    \
                :                                             \
                        '=d' (tmp)                                \
                :                                             \
                        'p'  (&(var))                             \
        );                                                \
        tmp;                                              \
})
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for avr-libc from the source code.
